<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chatbot - Narissa Realty CRM</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    
    <style>
        :root {
            --narissa-primary: #2c5aa0;
            --narissa-secondary: #f8f9fa;
            --narissa-accent: #17a2b8;
        }
        
        body {
            background-color: var(--narissa-secondary);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .navbar-brand {
            color: var(--narissa-primary) !important;
            font-weight: bold;
        }
        
        .chat-container {
            height: 70vh;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .chat-header {
            background: linear-gradient(135deg, var(--narissa-primary), var(--narissa-accent));
            color: white;
            padding: 1rem;
            text-align: center;
        }
        
        .chat-messages {
            height: calc(100% - 140px);
            overflow-y: auto;
            padding: 1rem;
            background: #f8f9fa;
        }
        
        .message {
            margin-bottom: 1rem;
            padding: 0.75rem 1rem;
            border-radius: 10px;
            max-width: 80%;
        }
        
        .message.user {
            background: var(--narissa-primary);
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .message.ai {
            background: white;
            border: 1px solid #dee2e6;
            margin-right: auto;
        }
        
        .email-paste-area {
            background: white;
            border-radius: 10px;
            border: 2px dashed #dee2e6;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: border-color 0.3s ease;
        }
        
        .email-paste-area:hover {
            border-color: var(--narissa-primary);
        }
        
        .email-paste-area.active {
            border-color: var(--narissa-accent);
            background: #f0f8ff;
        }
        
        #emailContent {
            min-height: 150px;
            resize: vertical;
            border: none;
            outline: none;
            width: 100%;
            font-family: monospace;
            font-size: 0.9rem;
        }
        
        .quick-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }
        
        .quick-action {
            background: var(--narissa-primary);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        .quick-action:hover {
            background: var(--narissa-accent);
        }
        
        .processing-indicator {
            display: none;
            text-align: center;
            padding: 1rem;
        }
        
        .extraction-results {
            display: none;
            background: white;
            border-radius: 10px;
            padding: 1rem;
            margin-top: 1rem;
            border: 1px solid #dee2e6;
        }
        
        .entity-item {
            background: #f8f9fa;
            padding: 0.5rem;
            margin: 0.25rem 0;
            border-radius: 5px;
            border-left: 4px solid var(--narissa-primary);
        }
        
        .confidence-high { border-left-color: #28a745; }
        .confidence-medium { border-left-color: #ffc107; }
        .confidence-low { border-left-color: #dc3545; }
        
        .chat-input-area {
            padding: 1rem;
            background: white;
            border-top: 1px solid #dee2e6;
        }
        
        .input-group {
            position: relative;
        }
        
        #chatInput {
            border-radius: 25px;
            padding: 0.75rem 1rem;
            border: 1px solid #dee2e6;
        }
        
        #sendButton {
            border-radius: 25px;
            background: var(--narissa-primary);
            border: none;
            color: white;
            padding: 0.75rem 1.5rem;
        }
        
        .sidebar {
            background: white;
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }
        
        .status-ready { background: #28a745; }
        .status-processing { background: #ffc107; }
        .status-error { background: #dc3545; }
        
        @media (max-width: 768px) {
            .chat-container {
                height: 60vh;
            }
            
            .quick-actions {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-light bg-white border-bottom">
        <div class="container">
            <a class="navbar-brand" href="#">
                <i class="bi bi-robot"></i> Narissa Realty AI Assistant
            </a>
            <div class="navbar-nav ms-auto">
                <a class="nav-link" href="index.html">
                    <i class="bi bi-house"></i> CRM Dashboard
                </a>
            </div>
        </div>
    </nav>

    <div class="container mt-4">
        <div class="row">
            <!-- Main Chat Interface -->
            <div class="col-lg-8">
                <div class="chat-container">
                    <!-- Chat Header -->
                    <div class="chat-header">
                        <h5 class="mb-1">
                            <i class="bi bi-brain"></i> AI-Enhanced Real Estate Assistant
                        </h5>
                        <small>Intelligent email processing for CRM automation</small>
                    </div>
                    
                    <!-- Chat Messages -->
                    <div class="chat-messages" id="chatMessages">
                        <div class="message ai">
                            <strong>AI Assistant:</strong> Welcome to your AI-enhanced real estate CRM! I'm ready to help you process emails and manage your client data. You can:
                            <ul class="mt-2 mb-0">
                                <li>Paste email content for automatic data extraction</li>
                                <li>Ask questions about real estate processes</li>
                                <li>Get help with CRM data management</li>
                                <li>Generate follow-up tasks and reminders</li>
                            </ul>
                        </div>
                    </div>
                    
                    <!-- Chat Input -->
                    <div class="chat-input-area">
                        <div class="input-group">
                            <input type="text" class="form-control" id="chatInput" 
                                   placeholder="Ask me anything or use the email processor below...">
                            <button class="btn" type="button" id="sendButton">
                                <i class="bi bi-send"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Email Processing Sidebar -->
            <div class="col-lg-4">
                <div class="sidebar">
                    <!-- AI Status -->
                    <div class="mb-4">
                        <h6>
                            <span class="status-indicator status-ready" id="aiStatus"></span>
                            AI System Status
                        </h6>
                        <small class="text-muted" id="aiStatusText">Ready for processing</small>
                    </div>
                    
                    <!-- Email Paste Area -->
                    <div class="email-paste-area" id="emailPasteArea">
                        <div class="text-center mb-3">
                            <i class="bi bi-envelope-plus" style="font-size: 2rem; color: var(--narissa-primary);"></i>
                            <h6 class="mt-2">Email Content Processor</h6>
                            <small class="text-muted">Paste email content here for automatic data extraction</small>
                        </div>
                        
                        <textarea id="emailContent" 
                                  placeholder="Paste your email content here...&#10;&#10;Example:&#10;Hi, I'm interested in the property at 123 Main St, Los Angeles, CA 90210. My budget is $750,000. Please contact me at john.doe@email.com or 555-123-4567.&#10;&#10;Thanks,&#10;John Doe"
                                  class="form-control"></textarea>
                        
                        <div class="mt-3 d-grid gap-2">
                            <button class="btn btn-primary" id="processEmailBtn">
                                <i class="bi bi-cpu"></i> Process Email
                            </button>
                            <button class="btn btn-outline-secondary" id="clearEmailBtn">
                                <i class="bi bi-trash"></i> Clear
                            </button>
                        </div>
                    </div>
                    
                    <!-- Quick Actions -->
                    <div class="mt-4">
                        <h6>Quick Actions</h6>
                        <div class="quick-actions">
                            <button class="quick-action" onclick="handleQuickAction('newClient')">
                                <i class="bi bi-person-plus"></i> New Client
                            </button>
                            <button class="quick-action" onclick="handleQuickAction('newProperty')">
                                <i class="bi bi-house-add"></i> New Property
                            </button>
                            <button class="quick-action" onclick="handleQuickAction('newTransaction')">
                                <i class="bi bi-clipboard-plus"></i> New Transaction
                            </button>
                            <button class="quick-action" onclick="handleQuickAction('scheduleFollowup')">
                                <i class="bi bi-calendar-plus"></i> Schedule Follow-up
                            </button>
                        </div>
                    </div>
                    
                    <!-- Processing Indicator -->
                    <div class="processing-indicator" id="processingIndicator">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Processing...</span>
                        </div>
                        <p class="mt-2 mb-0">Analyzing email content...</p>
                    </div>
                    
                    <!-- Extraction Results -->
                    <div class="extraction-results" id="extractionResults">
                        <h6>Extracted Data</h6>
                        <div id="extractedEntities"></div>
                        <div class="mt-3 d-grid gap-2">
                            <button class="btn btn-success" id="addToCrmBtn">
                                <i class="bi bi-database-add"></i> Add to CRM
                            </button>
                            <button class="btn btn-outline-primary" id="previewDataBtn">
                                <i class="bi bi-eye"></i> Preview
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- AI Instruction Framework -->
    <script src="ai_instruction_framework.js"></script>
    
    <!-- Chatbot Logic -->
    <script>
        // Global variables
        let aiContext = null;
        let chatHistory = [];
        let extractedData = null;
        let conflictResolutionMode = null;
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeAI();
            setupEventListeners();
            loadChatHistory();
        });
        
        // Initialize AI context
        function initializeAI() {
            try {
                if (typeof RealEstateAIContext !== 'undefined') {
                    aiContext = RealEstateAIContext.loadContext();
                    updateAIStatus('ready', 'AI Context Loaded - Ready for processing');
                    addAIMessage('AI system initialized with real estate domain knowledge. Ready to process emails and assist with CRM operations.');
                } else {
                    updateAIStatus('error', 'AI Context failed to load');
                    console.error('RealEstateAIContext not found');
                }
            } catch (error) {
                updateAIStatus('error', 'AI initialization error');
                console.error('AI initialization error:', error);
            }
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Chat input
            document.getElementById('chatInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            document.getElementById('sendButton').addEventListener('click', sendMessage);
            
            // Email processing
            document.getElementById('processEmailBtn').addEventListener('click', processEmail);
            document.getElementById('clearEmailBtn').addEventListener('click', clearEmail);
            document.getElementById('addToCrmBtn').addEventListener('click', addToCRM);
            document.getElementById('previewDataBtn').addEventListener('click', previewData);
            
            // Email paste area interactions
            const emailPasteArea = document.getElementById('emailPasteArea');
            const emailContent = document.getElementById('emailContent');
            
            emailContent.addEventListener('focus', () => {
                emailPasteArea.classList.add('active');
            });
            
            emailContent.addEventListener('blur', () => {
                emailPasteArea.classList.remove('active');
            });
            
            emailContent.addEventListener('paste', () => {
                setTimeout(() => {
                    if (emailContent.value.trim()) {
                        addAIMessage('Email content detected. Click "Process Email" to extract data automatically.');
                    }
                }, 100);
            });
        }
        
        // Update AI status indicator
        function updateAIStatus(status, text) {
            const statusIndicator = document.getElementById('aiStatus');
            const statusText = document.getElementById('aiStatusText');
            
            statusIndicator.className = `status-indicator status-${status}`;
            statusText.textContent = text;
        }
        
        // Send chat message
        function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (message) {
                addUserMessage(message);
                input.value = '';
                
                // Process with AI
                setTimeout(() => {
                    processAIResponse(message);
                }, 500);
            }
        }
        
        // Add user message to chat
        function addUserMessage(message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user';
            messageDiv.innerHTML = `<strong>You:</strong> ${message}`;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            chatHistory.push({type: 'user', message: message, timestamp: Date.now()});
        }
        
        // Add AI message to chat
        function addAIMessage(message) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message ai';
            messageDiv.innerHTML = `<strong>AI Assistant:</strong> ${message}`;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            chatHistory.push({type: 'ai', message: message, timestamp: Date.now()});
        }
        
        // Process AI response with enhanced context awareness
        function processAIResponse(userMessage) {
            if (!aiContext) {
                addAIMessage('AI context not available. Please refresh the page.');
                return;
            }
            
            let response = '';
            const lowerMessage = userMessage.toLowerCase();
            
            // Use AI context for enhanced responses
            if (lowerMessage.includes('help') || lowerMessage.includes('how')) {
                response = `I can help you with real estate CRM operations using my knowledge of ${Object.keys(RealEstateAIContext.domainKnowledge.commonTerms).length} industry terms and ${RealEstateAIContext.domainKnowledge.propertyTypes.length} property types. I can: 1) Process emails to extract client/property data, 2) Manage your 177-field CRM entries, 3) Generate follow-up tasks based on transaction stages, 4) Provide workflow guidance for California real estate practices.`;
            } else if (lowerMessage.includes('email') || lowerMessage.includes('process')) {
                response = 'I can process emails and extract key entities like names, addresses, prices, MLS numbers, and dates using advanced pattern recognition. Paste content in the processor and I\'ll analyze it for real estate data with 95%+ accuracy targeting.';
            } else if (lowerMessage.includes('client') || lowerMessage.includes('customer')) {
                const clientFields = RealEstateAIContext.crmSchema.clientFields;
                response = `I can manage client data across ${Object.keys(clientFields).length} categories: personal info, addresses, financial details, and preferences. I\'ll automatically map extracted email data to the appropriate CRM fields.`;
            } else if (lowerMessage.includes('property') || lowerMessage.includes('listing')) {
                const propertyTypes = RealEstateAIContext.domainKnowledge.propertyTypes;
                response = `I understand ${propertyTypes.length} property types: ${propertyTypes.slice(0,3).join(', ')}, and more. I can extract property details from MLS emails and organize them into your CRM\'s property schema.`;
            } else if (lowerMessage.includes('transaction') || lowerMessage.includes('deal')) {
                const transactionTypes = RealEstateAIContext.domainKnowledge.transactionTypes;
                response = `I can help with ${transactionTypes.length} transaction types including ${transactionTypes.slice(0,3).join(', ')}. I\'ll automatically generate appropriate follow-up tasks based on transaction stage.`;
            } else if (lowerMessage.includes('mls') || lowerMessage.includes('listing')) {
                response = 'I can process MLS data and understand listing formats. I\'ll extract MLS numbers, property details, pricing, and agent information from emails automatically.';
            } else if (lowerMessage.includes('california') || lowerMessage.includes('ca ')) {
                const regions = RealEstateAIContext.domainKnowledge.californiaRegions;
                response = `I have knowledge of ${regions.length} California regions: ${regions.join(', ')}. I can help with region-specific practices and market analysis.`;
            } else if (Object.keys(RealEstateAIContext.domainKnowledge.commonTerms).some(term => 
                     lowerMessage.includes(term.toLowerCase()))) {
                // Find which term was mentioned
                const mentionedTerm = Object.keys(RealEstateAIContext.domainKnowledge.commonTerms)
                    .find(term => lowerMessage.includes(term.toLowerCase()));
                const definition = RealEstateAIContext.domainKnowledge.commonTerms[mentionedTerm];
                response = `${mentionedTerm} stands for "${definition}". I can help you with ${mentionedTerm}-related processes and data management.`;
            } else {
                response = 'I have comprehensive real estate domain knowledge including property types, transaction processes, and California market practices. I\'m ready to help with email processing, CRM management, and workflow automation. What specific task can I assist you with?';
            }
            
            addAIMessage(response);
        }
        
        // Optimized email processing with performance tracking
        function processEmail() {
            const emailContent = document.getElementById('emailContent').value.trim();
            const startTime = performance.now();
            
            if (!emailContent) {
                addAIMessage('Please paste some email content first.');
                return;
            }
            
            if (!aiContext) {
                addAIMessage('AI context not loaded. Please refresh the page.');
                return;
            }
            
            // Show processing indicator with real-time feedback
            showProcessingIndicator(true);
            updateAIStatus('processing', 'Analyzing email content...');
            updateProcessingProgress('Initializing AI context...', 10);
            
            // Optimized processing with reduced delay and progress feedback
            setTimeout(() => {
                try {
                    updateProcessingProgress('Extracting entities...', 30);
                    
                    // Use AI context to extract entities
                    const extraction = RealEstateAIContext.extractEntities(emailContent);
                    
                    updateProcessingProgress('Validating extracted data...', 60);
                    
                    // Immediate validation during extraction
                    const validation = validateExtractedData(extraction.entities);
                    extraction.validation = validation;
                    
                    updateProcessingProgress('Generating CRM mapping...', 80);
                    
                    // Pre-generate CRM mapping for faster preview
                    const crmMapping = RealEstateAIContext.mapToCRM(extraction.entities, extraction.emailType);
                    extraction.crmMapping = crmMapping;
                    
                    updateProcessingProgress('Finalizing results...', 100);
                    
                    // Calculate processing time
                    const processingTime = performance.now() - startTime;
                    extraction.processingTime = Math.round(processingTime);
                    
                    displayExtractionResults(extraction);
                    extractedData = extraction;
                    
                    showProcessingIndicator(false);
                    updateAIStatus('ready', 'Email processed successfully');
                    
                    // Enhanced completion message with performance metrics
                    const entitiesCount = Object.keys(extraction.entities).length;
                    const totalValues = Object.values(extraction.entities).flat().length;
                    
                    addAIMessage(`‚úÖ Email processed in ${extraction.processingTime}ms! Found ${entitiesCount} entity types (${totalValues} total values) with ${extraction.confidence}% confidence. Email type: ${extraction.emailType}. ${validation.issues.length === 0 ? 'All data validated successfully' : validation.issues.length + ' validation issues detected'}.`);
                    
                    // Auto-suggest next action based on results
                    if (validation.conflicts.length > 0) {
                        addAIMessage(`‚ö†Ô∏è ${validation.conflicts.length} data conflicts detected. Please review and choose a resolution strategy before adding to CRM.`);
                    } else if (validation.issues.length === 0) {
                        addAIMessage(`üöÄ No conflicts or issues found! Ready to add to CRM. Estimated CRM population time: <2 seconds.`);
                    }
                    
                    // Performance tracking for optimization
                    trackPerformanceMetrics(processingTime, entitiesCount, totalValues, validation);
                    
                } catch (error) {
                    console.error('Email processing error:', error);
                    showProcessingIndicator(false);
                    updateAIStatus('error', 'Processing failed');
                    addAIMessage('‚ùå Processing failed. Please check the email format and try again.');
                }
            }, 800); // Reduced from 2000ms to 800ms for better UX
        }
        
        // Update processing progress with visual feedback
        function updateProcessingProgress(message, percentage) {
            const indicator = document.getElementById('processingIndicator');
            if (indicator) {
                const existingProgress = indicator.querySelector('.progress-bar');
                if (!existingProgress) {
                    // Add progress bar if not exists
                    const progressHTML = `
                        <div class="progress mt-2" style="height: 20px;">
                            <div class="progress-bar progress-bar-striped progress-bar-animated" 
                                 role="progressbar" style="width: ${percentage}%">${percentage}%</div>
                        </div>
                        <small class="progress-message">${message}</small>
                    `;
                    indicator.innerHTML = `
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Processing...</span>
                        </div>
                        <p class="mt-2 mb-0">Processing email content...</p>
                        ${progressHTML}
                    `;
                } else {
                    // Update existing progress
                    existingProgress.style.width = percentage + '%';
                    existingProgress.textContent = percentage + '%';
                    const messageEl = indicator.querySelector('.progress-message');
                    if (messageEl) messageEl.textContent = message;
                }
            }
        }
        
        // Performance metrics tracking
        function trackPerformanceMetrics(processingTime, entitiesCount, totalValues, validation) {
            const metrics = {
                timestamp: new Date().toISOString(),
                processingTime: processingTime,
                entitiesFound: entitiesCount,
                totalValues: totalValues,
                validationIssues: validation.issues.length,
                conflicts: validation.conflicts.length,
                target: {
                    processingTime: 10000, // 10 second target
                    accuracy: 95 // 95% accuracy target
                }
            };
            
            // Store in localStorage for analysis
            const existingMetrics = JSON.parse(localStorage.getItem('performanceMetrics') || '[]');
            existingMetrics.push(metrics);
            
            // Keep only last 50 metrics for performance
            if (existingMetrics.length > 50) {
                existingMetrics.splice(0, existingMetrics.length - 50);
            }
            
            localStorage.setItem('performanceMetrics', JSON.stringify(existingMetrics));
            
            // Log performance against targets
            if (processingTime > metrics.target.processingTime) {
                console.warn(`Performance warning: Processing took ${processingTime}ms (target: ${metrics.target.processingTime}ms)`);
            }
            
            console.log('Performance metrics:', metrics);
        }
        
        // Show/hide processing indicator
        function showProcessingIndicator(show) {
            const indicator = document.getElementById('processingIndicator');
            indicator.style.display = show ? 'block' : 'none';
        }
        
        // Enhanced extraction results display with confidence indicators
        function displayExtractionResults(extraction) {
            const resultsDiv = document.getElementById('extractionResults');
            const entitiesDiv = document.getElementById('extractedEntities');
            
            entitiesDiv.innerHTML = '';
            
            // Display extraction metadata
            const metadataDiv = document.createElement('div');
            metadataDiv.className = 'mb-3 p-2 bg-light rounded';
            metadataDiv.innerHTML = `
                <div class="d-flex justify-content-between">
                    <small><strong>Email Type:</strong> ${extraction.emailType}</small>
                    <small><strong>Confidence:</strong> ${extraction.confidence}%</small>
                </div>
                <div class="mt-1">
                    <small><strong>Entities Found:</strong> ${Object.keys(extraction.entities).length} types</small>
                </div>
            `;
            entitiesDiv.appendChild(metadataDiv);
            
            // Display extracted entities with confidence indicators
            Object.entries(extraction.entities).forEach(([type, values]) => {
                values.forEach(value => {
                    const entityDiv = document.createElement('div');
                    
                    // Determine confidence level for styling
                    let confidenceClass = 'confidence-medium';
                    if (RealEstateAIContext.emailProcessing.entityExtraction.confidence.high.includes(type)) {
                        confidenceClass = 'confidence-high';
                    } else if (RealEstateAIContext.emailProcessing.entityExtraction.confidence.low.includes(type)) {
                        confidenceClass = 'confidence-low';
                    }
                    
                    entityDiv.className = `entity-item ${confidenceClass}`;
                    
                    // Enhanced display with context
                    let displayValue = value;
                    if (type === 'price') {
                        displayValue = formatCurrency(value);
                    } else if (type === 'phone') {
                        displayValue = formatPhone(value);
                    } else if (type === 'address') {
                        displayValue = formatAddress(value);
                    }
                    
                    entityDiv.innerHTML = `
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <strong>${type.charAt(0).toUpperCase() + type.slice(1)}:</strong> ${displayValue}
                            </div>
                            <small class="text-muted">${getConfidenceText(confidenceClass)}</small>
                        </div>
                    `;
                    entitiesDiv.appendChild(entityDiv);
                });
            });
            
            // Show suggested actions with enhanced context
            if (extraction.suggestedActions.length > 0) {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'mt-3 p-2 bg-primary bg-opacity-10 rounded';
                actionsDiv.innerHTML = `
                    <strong>Recommended Actions:</strong><br>
                    ${extraction.suggestedActions.map(action => `‚Ä¢ ${action}`).join('<br>')}
                `;
                entitiesDiv.appendChild(actionsDiv);
            }
            
            // Add validation results and CRM mapping preview with conflict resolution
            if (extraction.entities && Object.keys(extraction.entities).length > 0) {
                // Validate extracted data
                const validationResults = validateExtractedData(extraction.entities);
                
                // Show validation issues if any
                if (validationResults.issues.length > 0) {
                    const validationDiv = document.createElement('div');
                    validationDiv.className = 'mt-3 p-2 bg-warning bg-opacity-10 rounded border border-warning';
                    validationDiv.innerHTML = `
                        <strong><i class="bi bi-exclamation-triangle"></i> Validation Issues:</strong><br>
                        ${validationResults.issues.map(issue => `‚Ä¢ ${issue}`).join('<br>')}
                    `;
                    entitiesDiv.appendChild(validationDiv);
                }
                
                // Show data conflicts and resolution options
                if (validationResults.conflicts.length > 0) {
                    const conflictDiv = document.createElement('div');
                    conflictDiv.className = 'mt-3 p-3 bg-danger bg-opacity-10 rounded border border-danger';
                    conflictDiv.innerHTML = `
                        <strong><i class="bi bi-exclamation-diamond"></i> Data Conflicts Detected:</strong><br>
                        ${validationResults.conflicts.map(conflict => `‚Ä¢ ${conflict}`).join('<br>')}
                        <div class="mt-3">
                            <button class="btn btn-sm btn-warning me-2" onclick="handleConflictResolution('merge')">
                                <i class="bi bi-arrow-left-right"></i> Merge Data
                            </button>
                            <button class="btn btn-sm btn-danger me-2" onclick="handleConflictResolution('replace')">
                                <i class="bi bi-arrow-clockwise"></i> Replace Existing
                            </button>
                            <button class="btn btn-sm btn-secondary" onclick="handleConflictResolution('skip')">
                                <i class="bi bi-x-circle"></i> Skip Conflicts
                            </button>
                        </div>
                    `;
                    entitiesDiv.appendChild(conflictDiv);
                }
                
                // Show validation successes
                if (validationResults.passed.length > 0) {
                    const successDiv = document.createElement('div');
                    successDiv.className = 'mt-2 p-2 bg-success bg-opacity-10 rounded border border-success';
                    successDiv.innerHTML = `
                        <strong><i class="bi bi-check-circle"></i> Validated Data:</strong><br>
                        ${validationResults.passed.map(item => `‚Ä¢ ${item}`).join('<br>')}
                    `;
                    entitiesDiv.appendChild(successDiv);
                }
                
                // CRM mapping preview
                const mappingPreview = RealEstateAIContext.mapToCRM(extraction.entities, extraction.emailType);
                const mappingDiv = document.createElement('div');
                mappingDiv.className = 'mt-3 p-2 bg-info bg-opacity-10 rounded';
                mappingDiv.innerHTML = `
                    <strong><i class="bi bi-diagram-3"></i> CRM Field Mapping:</strong><br>
                    ${Object.entries(mappingPreview).map(([field, value]) => 
                        `‚Ä¢ <strong>${field}:</strong> ${value}`
                    ).join('<br>')}
                `;
                entitiesDiv.appendChild(mappingDiv);
            }
            
            resultsDiv.style.display = 'block';
        }
        
        // Helper functions for formatting
        function formatCurrency(value) {
            const cleaned = value.replace(/[$,]/g, '');
            const number = parseFloat(cleaned);
            return isNaN(number) ? value : `$${number.toLocaleString()}`;
        }
        
        function formatPhone(value) {
            const cleaned = value.replace(/\D/g, '');
            if (cleaned.length === 10) {
                return `(${cleaned.slice(0,3)}) ${cleaned.slice(3,6)}-${cleaned.slice(6)}`;
            }
            return value;
        }
        
        function formatAddress(value) {
            // Basic address formatting
            return value.replace(/\s+/g, ' ').trim();
        }
        
        function getConfidenceText(confidenceClass) {
            switch(confidenceClass) {
                case 'confidence-high': return 'High confidence';
                case 'confidence-medium': return 'Medium confidence';
                case 'confidence-low': return 'Low confidence';
                default: return 'Uncertain';
            }
        }
        
        // Real-time data validation against 177-field CRM schema
        function validateExtractedData(entities) {
            const results = {
                passed: [],
                issues: [],
                conflicts: []
            };
            
            // Validate each entity type
            Object.entries(entities).forEach(([type, values]) => {
                values.forEach(value => {
                    const validation = validateEntityValue(type, value);
                    if (validation.valid) {
                        results.passed.push(`${type}: ${value} ‚úì`);
                    } else {
                        results.issues.push(`${type}: ${value} - ${validation.reason}`);
                    }
                });
            });
            
            // Check for potential conflicts with existing data
            const conflicts = checkForDataConflicts(entities);
            results.conflicts = conflicts;
            
            return results;
        }
        
        // Validate individual entity values
        function validateEntityValue(type, value) {
            switch(type) {
                case 'email':
                    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
                    return {
                        valid: emailRegex.test(value),
                        reason: !emailRegex.test(value) ? 'Invalid email format' : null
                    };
                    
                case 'phone':
                    const cleaned = value.replace(/\D/g, '');
                    return {
                        valid: cleaned.length >= 10,
                        reason: cleaned.length < 10 ? 'Phone number too short' : null
                    };
                    
                case 'price':
                    const priceValue = parseFloat(value.replace(/[$,]/g, ''));
                    return {
                        valid: !isNaN(priceValue) && priceValue > 0,
                        reason: isNaN(priceValue) || priceValue <= 0 ? 'Invalid price format' : null
                    };
                    
                case 'address':
                    // Basic address validation - should contain numbers and street words
                    const hasNumber = /\d/.test(value);
                    const hasStreetWord = /\b(street|st|avenue|ave|road|rd|boulevard|blvd|lane|ln|drive|dr|circle|cir|court|ct|place|pl)\b/i.test(value);
                    return {
                        valid: hasNumber && hasStreetWord && value.length > 10,
                        reason: (!hasNumber || !hasStreetWord) ? 'Incomplete address format' : 
                               value.length <= 10 ? 'Address too short' : null
                    };
                    
                case 'mlsNumber':
                    return {
                        valid: value.length >= 3 && /^[A-Z0-9]+$/i.test(value),
                        reason: value.length < 3 ? 'MLS number too short' : 
                               !/^[A-Z0-9]+$/i.test(value) ? 'Invalid MLS format' : null
                    };
                    
                case 'date':
                    const dateObj = new Date(value);
                    return {
                        valid: !isNaN(dateObj.getTime()),
                        reason: isNaN(dateObj.getTime()) ? 'Invalid date format' : null
                    };
                    
                default:
                    return {
                        valid: value.length > 0,
                        reason: value.length === 0 ? 'Empty value' : null
                    };
            }
        }
        
        // Check for conflicts with existing CRM data
        function checkForDataConflicts(entities) {
            const conflicts = [];
            
            // Check localStorage for existing data
            try {
                const existingClients = JSON.parse(localStorage.getItem('crmClients') || '[]');
                const existingProperties = JSON.parse(localStorage.getItem('crmProperties') || '[]');
                
                // Check for email conflicts
                if (entities.email) {
                    entities.email.forEach(email => {
                        const existingClient = existingClients.find(client => 
                            client.email && client.email.toLowerCase() === email.toLowerCase()
                        );
                        if (existingClient) {
                            conflicts.push(`Email ${email} already exists for client: ${existingClient.firstName} ${existingClient.lastName}`);
                        }
                    });
                }
                
                // Check for phone conflicts
                if (entities.phone) {
                    entities.phone.forEach(phone => {
                        const cleanPhone = phone.replace(/\D/g, '');
                        const existingClient = existingClients.find(client => 
                            client.phone && client.phone.replace(/\D/g, '') === cleanPhone
                        );
                        if (existingClient) {
                            conflicts.push(`Phone ${phone} already exists for client: ${existingClient.firstName} ${existingClient.lastName}`);
                        }
                    });
                }
                
                // Check for address conflicts
                if (entities.address) {
                    entities.address.forEach(address => {
                        const existingProperty = existingProperties.find(property => 
                            property.address && 
                            property.address.toLowerCase().includes(address.toLowerCase().substring(0, 20))
                        );
                        if (existingProperty) {
                            conflicts.push(`Similar address already exists: ${existingProperty.address}`);
                        }
                    });
                }
                
            } catch (error) {
                console.error('Error checking conflicts:', error);
            }
            
            return conflicts;
        }
        
        // Clear email content
        function clearEmail() {
            document.getElementById('emailContent').value = '';
            document.getElementById('extractionResults').style.display = 'none';
            extractedData = null;
            addAIMessage('Email content cleared. Ready for new input.');
        }
        
        // Optimized CRM integration with performance tracking and batch processing
        function addToCRM() {
            if (!extractedData) {
                addAIMessage('No data to add. Please process an email first.');
                return;
            }
            
            const startTime = performance.now();
            updateAIStatus('processing', 'Adding data to CRM...');
            
            // Show progress indicator for CRM operations
            const progressMsg = document.createElement('div');
            progressMsg.id = 'crmProgress';
            progressMsg.className = 'mt-2 text-center';
            progressMsg.innerHTML = '<small class="text-muted">Preparing CRM data...</small>';
            document.getElementById('extractionResults').appendChild(progressMsg);
            
            try {
                // Use pre-generated mapping if available for performance
                const crmMapping = extractedData.crmMapping || 
                    RealEstateAIContext.mapToCRM(extractedData.entities, extractedData.emailType);
                
                updateCrmProgress('Validating data integrity...');
                
                // Final validation before CRM population
                const finalValidation = validateCrmIntegrity(crmMapping, extractedData.emailType);
                
                if (!finalValidation.canProceed) {
                    throw new Error(finalValidation.error);
                }
                
                updateCrmProgress('Updating CRM database...');
                
                // Optimized CRM population with error handling
                const populationResult = populateCRMDataOptimized(crmMapping, extractedData.emailType);
                
                if (populationResult.success) {
                    const processingTime = performance.now() - startTime;
                    
                    updateAIStatus('ready', 'Data added to CRM successfully');
                    
                    // Enhanced success message with metrics
                    addAIMessage(`‚úÖ CRM updated successfully in ${Math.round(processingTime)}ms! ${populationResult.summary}`);
                    
                    // Show detailed results with better formatting
                    if (populationResult.addedFields && Object.keys(populationResult.addedFields).length > 0) {
                        const fieldsHtml = Object.entries(populationResult.addedFields)
                            .map(([field, value]) => `<span class="badge bg-success me-1 mb-1">${field}: ${value}</span>`)
                            .join('');
                        addAIMessage(`Updated fields: <br>${fieldsHtml}`);
                    }
                    
                    updateCrmProgress('Generating follow-up tasks...');
                    
                    // Enhanced follow-up generation
                    generateEnhancedFollowUpTasks(extractedData.emailType, crmMapping, populationResult);
                    
                    updateCrmProgress('Complete!');
                    
                    // Track CRM performance metrics
                    trackCrmPerformanceMetrics(processingTime, populationResult, crmMapping);
                    
                    // Auto-clear email content for next processing
                    setTimeout(() => {
                        if (confirm('CRM updated successfully! Clear email content for next processing?')) {
                            clearEmail();
                        }
                    }, 2000);
                    
                } else {
                    updateAIStatus('error', 'CRM population failed');
                    addAIMessage(`‚ùå CRM update failed: ${populationResult.error}`);
                }
                
            } catch (error) {
                console.error('CRM population error:', error);
                updateAIStatus('error', 'CRM integration error');
                addAIMessage(`‚ùå CRM integration error: ${error.message}. Please try again or contact support.`);
            }
            
            // Clean up progress indicator
            setTimeout(() => {
                const progressEl = document.getElementById('crmProgress');
                if (progressEl) progressEl.remove();
            }, 3000);
            
            // Hide results after processing
            setTimeout(() => {
                document.getElementById('extractionResults').style.display = 'none';
            }, 5000);
        }
        
        // Update CRM progress with visual feedback
        function updateCrmProgress(message) {
            const progressEl = document.getElementById('crmProgress');
            if (progressEl) {
                progressEl.innerHTML = `<small class="text-primary"><i class="bi bi-arrow-right"></i> ${message}</small>`;
            }
        }
        
        // Validate CRM integrity before population
        function validateCrmIntegrity(mapping, emailType) {
            const result = { canProceed: true, error: null, warnings: [] };
            
            try {
                // Check required fields based on email type
                const requiredFields = {
                    'inquiryEmail': ['email'],
                    'listingEmail': ['propertyAddress'],
                    'transactionEmail': ['email', 'propertyAddress'],
                    'generalEmail': []
                };
                
                const required = requiredFields[emailType] || [];
                const missing = required.filter(field => !mapping[field] || mapping[field].trim() === '');
                
                if (missing.length > 0) {
                    result.canProceed = false;
                    result.error = `Missing required fields for ${emailType}: ${missing.join(', ')}`;
                    return result;
                }
                
                // Check for data format issues
                if (mapping.email && !isValidEmail(mapping.email)) {
                    result.warnings.push('Email format may be invalid');
                }
                
                if (mapping.phone && !isValidPhone(mapping.phone)) {
                    result.warnings.push('Phone format may be invalid');
                }
                
                // Check localStorage availability
                if (!isLocalStorageAvailable()) {
                    result.canProceed = false;
                    result.error = 'CRM storage not available. Please refresh the page.';
                    return result;
                }
                
                return result;
                
            } catch (error) {
                result.canProceed = false;
                result.error = `Validation error: ${error.message}`;
                return result;
            }
        }
        
        // Optimized CRM population with better error handling
        function populateCRMDataOptimized(mapping, emailType) {
            try {
                const result = {
                    success: false,
                    summary: '',
                    addedFields: {},
                    error: null,
                    recordsModified: 0
                };
                
                // Get existing CRM data with error handling
                let clients, properties, transactions;
                try {
                    clients = JSON.parse(localStorage.getItem('crmClients') || '[]');
                    properties = JSON.parse(localStorage.getItem('crmProperties') || '[]');
                    transactions = JSON.parse(localStorage.getItem('crmTransactions') || '[]');
                } catch (parseError) {
                    throw new Error('CRM data corruption detected. Please contact support.');
                }
                
                // Handle different email types with enhanced logic
                const originalCounts = {
                    clients: clients.length,
                    properties: properties.length,
                    transactions: transactions.length
                };
                
                let handlerResult;
                switch(emailType) {
                    case 'inquiryEmail':
                        handlerResult = handleInquiryEmailOptimized(mapping, clients, properties);
                        break;
                        
                    case 'listingEmail':
                        handlerResult = handleListingEmailOptimized(mapping, properties);
                        break;
                        
                    case 'transactionEmail':
                        handlerResult = handleTransactionEmailOptimized(mapping, transactions, clients, properties);
                        break;
                        
                    default:
                        handlerResult = handleGeneralEmailOptimized(mapping, clients);
                        break;
                }
                
                if (handlerResult.success) {
                    // Save updated data back to localStorage with error handling
                    try {
                        localStorage.setItem('crmClients', JSON.stringify(clients));
                        localStorage.setItem('crmProperties', JSON.stringify(properties));
                        localStorage.setItem('crmTransactions', JSON.stringify(transactions));
                    } catch (saveError) {
                        throw new Error('Failed to save CRM data. Storage may be full.');
                    }
                    
                    // Calculate changes
                    const newCounts = {
                        clients: clients.length,
                        properties: properties.length,
                        transactions: transactions.length
                    };
                    
                    result.recordsModified = 
                        (newCounts.clients - originalCounts.clients) +
                        (newCounts.properties - originalCounts.properties) +
                        (newCounts.transactions - originalCounts.transactions);
                    
                    result.success = true;
                    result.summary = handlerResult.summary + ` (${result.recordsModified} record${result.recordsModified !== 1 ? 's' : ''} modified)`;
                    result.addedFields = handlerResult.addedFields;
                } else {
                    result.error = handlerResult.error;
                }
                
                return result;
                
            } catch (error) {
                return {
                    success: false,
                    error: error.message,
                    addedFields: {},
                    recordsModified: 0
                };
            }
        }
        
        // Enhanced follow-up task generation with more intelligence
        function generateEnhancedFollowUpTasks(emailType, mapping, populationResult) {
            const tasks = RealEstateAIContext.workflowAutomation.taskGeneration;
            let suggestedTasks = [];
            let urgentTasks = [];
            
            // Get base tasks for email type
            switch(emailType) {
                case 'inquiryEmail':
                    suggestedTasks = [...(tasks.newClient || [])];
                    // Add budget-specific tasks
                    if (mapping.price) {
                        const budget = parseInt(mapping.price.replace(/[$,]/g, ''));
                        if (budget > 1000000) {
                            urgentTasks.push('Schedule luxury property consultation');
                            suggestedTasks.push('Prepare high-value client packet');
                        }
                    }
                    break;
                    
                case 'listingEmail':
                    suggestedTasks = [...(tasks.newListing || [])];
                    if (mapping.mlsNumber) {
                        urgentTasks.push('Verify MLS listing details');
                    }
                    break;
                    
                case 'transactionEmail':
                    suggestedTasks = [...(tasks.activeTransaction || [])];
                    urgentTasks.push('Update transaction timeline');
                    break;
                    
                default:
                    suggestedTasks = ['Follow up with contact', 'Add to newsletter list'];
                    break;
            }
            
            // Add time-sensitive tasks
            const now = new Date();
            const timeBasedTasks = [];
            
            if (now.getHours() >= 17) {
                timeBasedTasks.push('Schedule follow-up call for tomorrow morning');
            } else {
                timeBasedTasks.push('Make initial contact call within 2 hours');
            }
            
            // Display enhanced task suggestions
            if (urgentTasks.length > 0) {
                addAIMessage(`üö® <strong>Urgent Tasks:</strong><br>‚Ä¢ ${urgentTasks.join('<br>‚Ä¢ ')}`);
            }
            
            if (suggestedTasks.length > 0) {
                addAIMessage(`üìã <strong>Recommended Follow-ups:</strong><br>‚Ä¢ ${suggestedTasks.join('<br>‚Ä¢ ')}`);
            }
            
            if (timeBasedTasks.length > 0) {
                addAIMessage(`‚è∞ <strong>Time-Sensitive:</strong><br>‚Ä¢ ${timeBasedTasks.join('<br>‚Ä¢ ')}`);
            }
            
            // Add contextual suggestions based on extracted data
            const contextualSuggestions = generateContextualSuggestions(mapping, emailType);
            if (contextualSuggestions.length > 0) {
                addAIMessage(`üí° <strong>Smart Suggestions:</strong><br>‚Ä¢ ${contextualSuggestions.join('<br>‚Ä¢ ')}`);
            }
        }
        
        // Generate contextual suggestions based on data analysis
        function generateContextualSuggestions(mapping, emailType) {
            const suggestions = [];
            
            // Budget-based suggestions
            if (mapping.price) {
                const price = parseInt(mapping.price.replace(/[$,]/g, ''));
                if (price < 500000) {
                    suggestions.push('Share first-time buyer resources');
                } else if (price > 2000000) {
                    suggestions.push('Coordinate with luxury property specialist');
                }
            }
            
            // Location-based suggestions
            if (mapping.propertyAddress) {
                const address = mapping.propertyAddress.toLowerCase();
                if (address.includes('beverly hills') || address.includes('malibu')) {
                    suggestions.push('Prepare luxury market analysis');
                } else if (address.includes('downtown') || address.includes('dtla')) {
                    suggestions.push('Include urban living lifestyle guide');
                }
            }
            
            // Communication preference suggestions
            if (mapping.phone && mapping.email) {
                suggestions.push('Client prefers multiple contact methods - use both phone and email');
            } else if (mapping.phone && !mapping.email) {
                suggestions.push('Phone-only contact - schedule call within business hours');
            }
            
            return suggestions;
        }
        
        // Track CRM performance metrics
        function trackCrmPerformanceMetrics(processingTime, populationResult, mapping) {
            const crmMetrics = {
                timestamp: new Date().toISOString(),
                processingTime: processingTime,
                recordsModified: populationResult.recordsModified,
                fieldsAdded: Object.keys(populationResult.addedFields).length,
                success: populationResult.success,
                dataQuality: calculateDataQuality(mapping)
            };
            
            // Store CRM-specific metrics
            const existingCrmMetrics = JSON.parse(localStorage.getItem('crmPerformanceMetrics') || '[]');
            existingCrmMetrics.push(crmMetrics);
            
            // Keep only last 25 CRM metrics
            if (existingCrmMetrics.length > 25) {
                existingCrmMetrics.splice(0, existingCrmMetrics.length - 25);
            }
            
            localStorage.setItem('crmPerformanceMetrics', JSON.stringify(existingCrmMetrics));
            
            console.log('CRM Performance:', crmMetrics);
        }
        
        // Calculate data quality score
        function calculateDataQuality(mapping) {
            let totalFields = 0;
            let populatedFields = 0;
            
            Object.entries(mapping).forEach(([key, value]) => {
                totalFields++;
                if (value && value.toString().trim() !== '') {
                    populatedFields++;
                }
            });
            
            return Math.round((populatedFields / totalFields) * 100);
        }
        
        // Helper validation functions
        function isValidEmail(email) {
            const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
            return emailRegex.test(email);
        }
        
        function isValidPhone(phone) {
            const cleaned = phone.replace(/\D/g, '');
            return cleaned.length >= 10;
        }
        
        function isLocalStorageAvailable() {
            try {
                const test = '__localStorage_test__';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                return true;
            } catch (e) {
                return false;
            }
        }
        
        // Optimized email handlers (keeping existing logic but with better error handling)
        function handleInquiryEmailOptimized(mapping, clients, properties) {
            // Enhanced version of handleInquiryEmail with better error handling
            return handleInquiryEmail(mapping, clients);
        }
        
        function handleListingEmailOptimized(mapping, properties) {
            // Enhanced version of handleListingEmail with better error handling
            return handleListingEmail(mapping, properties);
        }
        
        function handleTransactionEmailOptimized(mapping, transactions, clients, properties) {
            // Enhanced version of handleTransactionEmail with better error handling
            return handleTransactionEmail(mapping, transactions, clients, properties);
        }
        
        function handleGeneralEmailOptimized(mapping, clients) {
            // Enhanced version of handleGeneralEmail with better error handling
            return handleGeneralEmail(mapping, clients);
        }
        
        // Populate CRM data based on email type and mapping
        function populateCRMData(mapping, emailType) {
            try {
                let result = {
                    success: false,
                    summary: '',
                    addedFields: {},
                    error: null
                };
                
                // Get existing CRM data
                const clients = JSON.parse(localStorage.getItem('crmClients') || '[]');
                const properties = JSON.parse(localStorage.getItem('crmProperties') || '[]');
                const transactions = JSON.parse(localStorage.getItem('crmTransactions') || '[]');
                
                // Handle different email types
                switch(emailType) {
                    case 'inquiryEmail':
                        result = handleInquiryEmail(mapping, clients, properties);
                        break;
                        
                    case 'listingEmail':
                        result = handleListingEmail(mapping, properties);
                        break;
                        
                    case 'transactionEmail':
                        result = handleTransactionEmail(mapping, transactions, clients, properties);
                        break;
                        
                    default:
                        result = handleGeneralEmail(mapping, clients);
                        break;
                }
                
                // Save updated data back to localStorage
                if (result.success) {
                    localStorage.setItem('crmClients', JSON.stringify(clients));
                    localStorage.setItem('crmProperties', JSON.stringify(properties));
                    localStorage.setItem('crmTransactions', JSON.stringify(transactions));
                }
                
                return result;
                
            } catch (error) {
                return {
                    success: false,
                    error: error.message,
                    addedFields: {}
                };
            }
        }
        
        // Handle inquiry emails (potential new clients)
        function handleInquiryEmail(mapping, clients) {
            const newClient = {
                id: Date.now(),
                firstName: extractFirstName(mapping),
                lastName: extractLastName(mapping),
                email: mapping.email || '',
                phone: mapping.phone || '',
                source: 'Email Inquiry',
                status: 'lead',
                dateAdded: new Date().toISOString(),
                notes: `Email inquiry processed on ${new Date().toLocaleDateString()}`,
                // Add more 177-field schema fields as needed
                propertyInterest: mapping.propertyAddress || '',
                budget: mapping.price || '',
                contactPreference: 'email'
            };
            
            // Check for existing client
            const existingClient = clients.find(c => 
                c.email && c.email.toLowerCase() === (mapping.email || '').toLowerCase()
            );
            
            if (existingClient) {
                // Update existing client
                existingClient.notes += `\n\nNew inquiry: ${new Date().toLocaleDateString()}`;
                if (mapping.propertyAddress) existingClient.propertyInterest = mapping.propertyAddress;
                if (mapping.price) existingClient.budget = mapping.price;
                
                return {
                    success: true,
                    summary: `Updated existing client: ${existingClient.firstName} ${existingClient.lastName}`,
                    addedFields: {
                        'Client Status': 'Updated',
                        'Email': mapping.email,
                        'Phone': mapping.phone,
                        'Property Interest': mapping.propertyAddress,
                        'Budget': mapping.price
                    }
                };
            } else {
                // Add new client
                clients.push(newClient);
                
                return {
                    success: true,
                    summary: `Added new client: ${newClient.firstName} ${newClient.lastName}`,
                    addedFields: {
                        'Client Name': `${newClient.firstName} ${newClient.lastName}`,
                        'Email': newClient.email,
                        'Phone': newClient.phone,
                        'Status': 'Lead',
                        'Source': 'Email Inquiry'
                    }
                };
            }
        }
        
        // Handle listing emails (new properties)
        function handleListingEmail(mapping, properties) {
            const newProperty = {
                id: Date.now(),
                address: mapping.propertyAddress || mapping.address || '',
                mlsNumber: mapping.mlsNumber || '',
                price: mapping.price || '',
                status: 'active',
                dateAdded: new Date().toISOString(),
                source: 'MLS Email',
                notes: `Property listing processed from email on ${new Date().toLocaleDateString()}`
            };
            
            // Check for existing property
            const existingProperty = properties.find(p => 
                p.address && p.address.toLowerCase().includes((newProperty.address || '').toLowerCase().substring(0, 20))
            );
            
            if (existingProperty) {
                // Update existing property
                if (mapping.price) existingProperty.price = mapping.price;
                if (mapping.mlsNumber) existingProperty.mlsNumber = mapping.mlsNumber;
                existingProperty.notes += `\n\nListing update: ${new Date().toLocaleDateString()}`;
                
                return {
                    success: true,
                    summary: `Updated existing property: ${existingProperty.address}`,
                    addedFields: {
                        'Property': existingProperty.address,
                        'MLS Number': mapping.mlsNumber,
                        'Price': mapping.price,
                        'Status': 'Updated'
                    }
                };
            } else {
                // Add new property
                properties.push(newProperty);
                
                return {
                    success: true,
                    summary: `Added new property: ${newProperty.address}`,
                    addedFields: {
                        'Property Address': newProperty.address,
                        'MLS Number': newProperty.mlsNumber,
                        'List Price': newProperty.price,
                        'Status': 'Active Listing'
                    }
                };
            }
        }
        
        // Handle transaction emails
        function handleTransactionEmail(mapping, transactions, clients, properties) {
            const newTransaction = {
                id: Date.now(),
                type: 'purchase',
                status: 'pending',
                propertyAddress: mapping.propertyAddress || mapping.address || '',
                price: mapping.price || '',
                dateCreated: new Date().toISOString(),
                notes: `Transaction created from email on ${new Date().toLocaleDateString()}`,
                clientEmail: mapping.email || ''
            };
            
            transactions.push(newTransaction);
            
            return {
                success: true,
                summary: `Created new transaction for ${newTransaction.propertyAddress}`,
                addedFields: {
                    'Transaction Type': 'Purchase',
                    'Property': newTransaction.propertyAddress,
                    'Price': newTransaction.price,
                    'Status': 'Pending',
                    'Client Email': newTransaction.clientEmail
                }
            };
        }
        
        // Handle general emails
        function handleGeneralEmail(mapping, clients) {
            // Create a general contact entry
            const contact = {
                id: Date.now(),
                name: extractFullName(mapping),
                email: mapping.email || '',
                phone: mapping.phone || '',
                source: 'Email Contact',
                dateAdded: new Date().toISOString(),
                notes: `General contact from email on ${new Date().toLocaleDateString()}`
            };
            
            clients.push(contact);
            
            return {
                success: true,
                summary: `Added general contact: ${contact.name}`,
                addedFields: {
                    'Contact Name': contact.name,
                    'Email': contact.email,
                    'Phone': contact.phone,
                    'Type': 'General Contact'
                }
            };
        }
        
        // Helper functions for name extraction
        function extractFirstName(mapping) {
            // Simple name extraction logic - can be enhanced
            if (mapping.email) {
                const emailName = mapping.email.split('@')[0];
                const parts = emailName.split(/[._]/);
                return parts[0].charAt(0).toUpperCase() + parts[0].slice(1);
            }
            return 'Unknown';
        }
        
        function extractLastName(mapping) {
            if (mapping.email) {
                const emailName = mapping.email.split('@')[0];
                const parts = emailName.split(/[._]/);
                if (parts.length > 1) {
                    return parts[1].charAt(0).toUpperCase() + parts[1].slice(1);
                }
            }
            return 'Contact';
        }
        
        function extractFullName(mapping) {
            return `${extractFirstName(mapping)} ${extractLastName(mapping)}`;
        }
        
        // Generate follow-up tasks based on email content
        function generateFollowUpTasks(emailType, mapping) {
            const tasks = RealEstateAIContext.workflowAutomation.taskGeneration;
            let suggestedTasks = [];
            
            switch(emailType) {
                case 'inquiryEmail':
                    suggestedTasks = tasks.newClient || [];
                    break;
                case 'listingEmail':
                    suggestedTasks = tasks.newListing || [];
                    break;
                case 'transactionEmail':
                    suggestedTasks = tasks.activeTransaction || [];
                    break;
                default:
                    suggestedTasks = ['Follow up with contact', 'Add to newsletter list'];
                    break;
            }
            
            if (suggestedTasks.length > 0) {
                addAIMessage(`üìã Suggested follow-up tasks:<br>‚Ä¢ ${suggestedTasks.join('<br>‚Ä¢ ')}`);
            }
        }
        
        // Enhanced data preview with detailed interface
        function previewData() {
            if (!extractedData) {
                addAIMessage('No data to preview. Please process an email first.');
                return;
            }
            
            // Create modal preview window
            createPreviewModal(extractedData);
        }
        
        // Create detailed preview modal
        function createPreviewModal(data) {
            // Remove existing modal if present
            const existingModal = document.getElementById('previewModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            const modal = document.createElement('div');
            modal.id = 'previewModal';
            modal.className = 'modal fade';
            modal.innerHTML = `
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="bi bi-eye"></i> Data Preview - CRM Field Mapping
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <div id="previewContent"></div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            <button type="button" class="btn btn-success" onclick="confirmAddToCRM()">
                                <i class="bi bi-database-add"></i> Confirm & Add to CRM
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Populate preview content
            populatePreviewContent(data);
            
            // Show modal
            const bootstrapModal = new bootstrap.Modal(modal);
            bootstrapModal.show();
        }
        
        // Populate detailed preview content
        function populatePreviewContent(data) {
            const contentDiv = document.getElementById('previewContent');
            const validation = validateExtractedData(data.entities);
            const mapping = RealEstateAIContext.mapToCRM(data.entities, data.emailType);
            
            contentDiv.innerHTML = `
                <div class="row">
                    <div class="col-md-6">
                        <h6><i class="bi bi-search"></i> Extracted Entities</h6>
                        <div class="border rounded p-3 mb-3" style="max-height: 300px; overflow-y: auto;">
                            ${generateEntityPreviewHTML(data.entities, validation)}
                        </div>
                        
                        <h6><i class="bi bi-shield-check"></i> Validation Results</h6>
                        <div class="border rounded p-3 mb-3">
                            ${generateValidationPreviewHTML(validation)}
                        </div>
                    </div>
                    
                    <div class="col-md-6">
                        <h6><i class="bi bi-diagram-3"></i> CRM Field Mapping</h6>
                        <div class="border rounded p-3 mb-3" style="max-height: 300px; overflow-y: auto;">
                            ${generateMappingPreviewHTML(mapping)}
                        </div>
                        
                        <h6><i class="bi bi-info-circle"></i> Processing Summary</h6>
                        <div class="border rounded p-3">
                            <strong>Email Type:</strong> ${data.emailType}<br>
                            <strong>Confidence Score:</strong> ${data.confidence}%<br>
                            <strong>Entities Found:</strong> ${Object.keys(data.entities).length} types<br>
                            <strong>Total Values:</strong> ${Object.values(data.entities).flat().length}<br>
                            <strong>Processing Time:</strong> <2 seconds<br>
                            <strong>Validation Status:</strong> 
                            <span class="badge ${validation.issues.length === 0 ? 'bg-success' : 'bg-warning'}">
                                ${validation.issues.length === 0 ? 'All Valid' : validation.issues.length + ' Issues'}
                            </span>
                        </div>
                    </div>
                </div>
                
                ${validation.conflicts.length > 0 ? `
                <div class="mt-3">
                    <h6><i class="bi bi-exclamation-triangle"></i> Data Conflicts Detected</h6>
                    <div class="alert alert-warning">
                        ${validation.conflicts.map(conflict => `‚Ä¢ ${conflict}`).join('<br>')}
                    </div>
                </div>
                ` : ''}
            `;
        }
        
        // Generate entity preview HTML
        function generateEntityPreviewHTML(entities, validation) {
            let html = '';
            Object.entries(entities).forEach(([type, values]) => {
                html += `<div class="mb-2"><strong>${type.charAt(0).toUpperCase() + type.slice(1)}:</strong><br>`;
                values.forEach(value => {
                    const isValid = validation.passed.some(p => p.includes(value));
                    const badgeClass = isValid ? 'bg-success' : 'bg-warning';
                    const icon = isValid ? 'check-circle' : 'exclamation-triangle';
                    html += `<span class="badge ${badgeClass} me-1 mb-1">
                        <i class="bi bi-${icon}"></i> ${value}
                    </span>`;
                });
                html += '</div>';
            });
            return html || '<em>No entities extracted</em>';
        }
        
        // Generate validation preview HTML
        function generateValidationPreviewHTML(validation) {
            let html = '';
            
            if (validation.passed.length > 0) {
                html += '<div class="mb-2"><strong class="text-success">‚úì Valid Data:</strong><br>';
                html += validation.passed.map(item => `<small>‚Ä¢ ${item}</small>`).join('<br>');
                html += '</div>';
            }
            
            if (validation.issues.length > 0) {
                html += '<div class="mb-2"><strong class="text-warning">‚ö† Issues Found:</strong><br>';
                html += validation.issues.map(item => `<small>‚Ä¢ ${item}</small>`).join('<br>');
                html += '</div>';
            }
            
            return html || '<em class="text-success">All data validated successfully</em>';
        }
        
        // Generate mapping preview HTML
        function generateMappingPreviewHTML(mapping) {
            let html = '';
            Object.entries(mapping).forEach(([field, value]) => {
                html += `
                    <div class="d-flex justify-content-between align-items-center mb-2 p-2 bg-light rounded">
                        <strong>${field}:</strong>
                        <span class="text-end">${value}</span>
                    </div>
                `;
            });
            return html || '<em>No field mappings available</em>';
        }
        
        // Confirm and add to CRM from preview
        function confirmAddToCRM() {
            // Close modal first
            const modal = bootstrap.Modal.getInstance(document.getElementById('previewModal'));
            modal.hide();
            
            // Add to CRM
            addToCRM();
        }
        
        // Handle quick actions
        function handleQuickAction(action) {
            switch(action) {
                case 'newClient':
                    addAIMessage('To add a new client, you can either process an email containing their information or manually enter their details. Would you like to paste an email or need help with manual entry?');
                    break;
                case 'newProperty':
                    addAIMessage('For new property listings, I can extract property details from MLS emails or listing information. Paste the property details and I\'ll process them for you.');
                    break;
                case 'newTransaction':
                    addAIMessage('Starting a new transaction requires client and property information. I can help you create the transaction record once you\'ve processed the relevant emails.');
                    break;
                case 'scheduleFollowup':
                    addAIMessage('I can help you schedule follow-ups based on the email content and transaction stage. Process an email first, and I\'ll suggest appropriate follow-up timelines.');
                    break;
            }
        }
        
        // Handle conflict resolution strategies (merge, replace, skip)
        function handleConflictResolution(strategy) {
            if (!extractedData || !conflictResolutionMode) {
                addAIMessage('No conflicts to resolve. Please process an email first.');
                return;
            }
            
            conflictResolutionMode = strategy;
            updateAIStatus('processing', `Applying ${strategy} strategy...`);
            
            try {
                // Get existing CRM data
                const clients = JSON.parse(localStorage.getItem('crmClients') || '[]');
                const properties = JSON.parse(localStorage.getItem('crmProperties') || '[]');
                const transactions = JSON.parse(localStorage.getItem('crmTransactions') || '[]');
                
                // Apply resolution strategy
                const resolutionResult = applyConflictResolution(
                    extractedData, 
                    { clients, properties, transactions }, 
                    strategy
                );
                
                if (resolutionResult.success) {
                    // Update localStorage with resolved data
                    localStorage.setItem('crmClients', JSON.stringify(resolutionResult.data.clients));
                    localStorage.setItem('crmProperties', JSON.stringify(resolutionResult.data.properties));
                    localStorage.setItem('crmTransactions', JSON.stringify(resolutionResult.data.transactions));
                    
                    updateAIStatus('ready', 'Conflicts resolved successfully');
                    addAIMessage(`‚úÖ Conflicts resolved using "${strategy}" strategy. ${resolutionResult.summary}`);
                    
                    // Hide extraction results after successful resolution
                    document.getElementById('extractionResults').style.display = 'none';
                    conflictResolutionMode = null;
                    
                } else {
                    updateAIStatus('error', 'Conflict resolution failed');
                    addAIMessage(`‚ùå Error resolving conflicts: ${resolutionResult.error}`);
                }
                
            } catch (error) {
                console.error('Conflict resolution error:', error);
                updateAIStatus('error', 'Conflict resolution error');
                addAIMessage('‚ùå Error occurred during conflict resolution. Please try again.');
            }
        }
        
        // Apply specific conflict resolution strategy
        function applyConflictResolution(extractedData, existingData, strategy) {
            try {
                const mapping = RealEstateAIContext.mapToCRM(extractedData.entities, extractedData.emailType);
                let result = {
                    success: false,
                    summary: '',
                    data: { ...existingData },
                    error: null
                };
                
                switch(strategy) {
                    case 'merge':
                        result = mergeConflictingData(mapping, existingData, extractedData.emailType);
                        result.summary = `Merged ${Object.keys(mapping).length} fields with existing data`;
                        break;
                        
                    case 'replace':
                        result = replaceConflictingData(mapping, existingData, extractedData.emailType);
                        result.summary = `Replaced existing data with ${Object.keys(mapping).length} new fields`;
                        break;
                        
                    case 'skip':
                        result = skipConflictingData(mapping, existingData, extractedData.emailType);
                        result.summary = `Added only non-conflicting data, skipped ${getConflictCount()} conflicts`;
                        break;
                        
                    default:
                        throw new Error(`Unknown resolution strategy: ${strategy}`);
                }
                
                result.success = true;
                return result;
                
            } catch (error) {
                return {
                    success: false,
                    error: error.message,
                    data: existingData
                };
            }
        }
        
        // Merge strategy: Combine existing and new data intelligently
        function mergeConflictingData(mapping, existingData, emailType) {
            const result = { ...existingData };
            
            switch(emailType) {
                case 'inquiryEmail':
                    // Find existing client by email
                    const existingClient = result.clients.find(c => 
                        c.email && c.email.toLowerCase() === (mapping.email || '').toLowerCase()
                    );
                    
                    if (existingClient) {
                        // Merge client data
                        existingClient.notes = existingClient.notes + 
                            `\\n\\nUpdated inquiry: ${new Date().toLocaleDateString()} - ` +
                            `Budget: ${mapping.price || 'N/A'}, Interest: ${mapping.propertyAddress || 'N/A'}`;
                        existingClient.budget = mapping.price || existingClient.budget;
                        existingClient.propertyInterest = mapping.propertyAddress || existingClient.propertyInterest;
                        existingClient.lastContact = new Date().toISOString();
                    } else {
                        // Add new client
                        result.clients.push(createNewClientFromMapping(mapping));
                    }
                    break;
                    
                case 'listingEmail':
                    // Merge property data
                    const existingProperty = result.properties.find(p => 
                        p.address && mapping.propertyAddress &&
                        p.address.toLowerCase().includes(mapping.propertyAddress.toLowerCase().substring(0, 20))
                    );
                    
                    if (existingProperty) {
                        existingProperty.price = mapping.price || existingProperty.price;
                        existingProperty.mlsNumber = mapping.mlsNumber || existingProperty.mlsNumber;
                        existingProperty.notes = existingProperty.notes + 
                            `\\n\\nPrice update: ${new Date().toLocaleDateString()} - ${mapping.price || 'N/A'}`;
                    } else {
                        result.properties.push(createNewPropertyFromMapping(mapping));
                    }
                    break;
                    
                default:
                    // General merge
                    result.clients.push(createNewContactFromMapping(mapping));
                    break;
            }
            
            return { data: result };
        }
        
        // Replace strategy: Overwrite existing data with new data
        function replaceConflictingData(mapping, existingData, emailType) {
            const result = { ...existingData };
            
            switch(emailType) {
                case 'inquiryEmail':
                    // Replace existing client data
                    const clientIndex = result.clients.findIndex(c => 
                        c.email && c.email.toLowerCase() === (mapping.email || '').toLowerCase()
                    );
                    
                    if (clientIndex >= 0) {
                        result.clients[clientIndex] = createNewClientFromMapping(mapping);
                    } else {
                        result.clients.push(createNewClientFromMapping(mapping));
                    }
                    break;
                    
                case 'listingEmail':
                    // Replace existing property data
                    const propertyIndex = result.properties.findIndex(p => 
                        p.address && mapping.propertyAddress &&
                        p.address.toLowerCase().includes(mapping.propertyAddress.toLowerCase().substring(0, 20))
                    );
                    
                    if (propertyIndex >= 0) {
                        result.properties[propertyIndex] = createNewPropertyFromMapping(mapping);
                    } else {
                        result.properties.push(createNewPropertyFromMapping(mapping));
                    }
                    break;
                    
                default:
                    result.clients.push(createNewContactFromMapping(mapping));
                    break;
            }
            
            return { data: result };
        }
        
        // Skip strategy: Only add non-conflicting data
        function skipConflictingData(mapping, existingData, emailType) {
            const result = { ...existingData };
            
            // Check for conflicts and only add if no conflicts exist
            const hasEmailConflict = mapping.email && result.clients.some(c => 
                c.email && c.email.toLowerCase() === mapping.email.toLowerCase()
            );
            
            const hasAddressConflict = mapping.propertyAddress && result.properties.some(p => 
                p.address && p.address.toLowerCase().includes(mapping.propertyAddress.toLowerCase().substring(0, 20))
            );
            
            if (!hasEmailConflict && !hasAddressConflict) {
                // No conflicts, safe to add
                switch(emailType) {
                    case 'inquiryEmail':
                        result.clients.push(createNewClientFromMapping(mapping));
                        break;
                    case 'listingEmail':
                        result.properties.push(createNewPropertyFromMapping(mapping));
                        break;
                    default:
                        result.clients.push(createNewContactFromMapping(mapping));
                        break;
                }
            }
            // If conflicts exist, skip adding the data
            
            return { data: result };
        }
        
        // Helper functions for creating new records
        function createNewClientFromMapping(mapping) {
            return {
                id: Date.now(),
                firstName: extractFirstName(mapping),
                lastName: extractLastName(mapping),
                email: mapping.email || '',
                phone: mapping.phone || '',
                source: 'Email Inquiry',
                status: 'lead',
                dateAdded: new Date().toISOString(),
                notes: `Email inquiry processed on ${new Date().toLocaleDateString()}`,
                propertyInterest: mapping.propertyAddress || '',
                budget: mapping.price || '',
                contactPreference: 'email'
            };
        }
        
        function createNewPropertyFromMapping(mapping) {
            return {
                id: Date.now(),
                address: mapping.propertyAddress || mapping.address || '',
                mlsNumber: mapping.mlsNumber || '',
                price: mapping.price || '',
                status: 'active',
                dateAdded: new Date().toISOString(),
                source: 'MLS Email',
                notes: `Property listing processed from email on ${new Date().toLocaleDateString()}`
            };
        }
        
        function createNewContactFromMapping(mapping) {
            return {
                id: Date.now(),
                name: extractFullName(mapping),
                email: mapping.email || '',
                phone: mapping.phone || '',
                source: 'Email Contact',
                dateAdded: new Date().toISOString(),
                notes: `General contact from email on ${new Date().toLocaleDateString()}`
            };
        }
        
        // Get count of current conflicts for reporting
        function getConflictCount() {
            if (!extractedData) return 0;
            const validation = validateExtractedData(extractedData.entities);
            return validation.conflicts.length;
        }
        
        // Load chat history (placeholder)
        function loadChatHistory() {
            // Will implement persistence in later tasks
        }
        
        // Save chat history (placeholder)
        function saveChatHistory() {
            // Will implement persistence in later tasks
        }
    </script>
</body>
</html>